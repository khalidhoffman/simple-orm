import "reflect-metadata";

import { SimpleORM }          from './core';
import {
  PropertyMeta,
  PropertyRelationMeta
} from './meta';
import { EntityRelationType } from './entity-relation';

export function Column(columnOptions) {

  return function (object, propertyName) {
    const options = {
      type: 'string',
      sql: {
        name: propertyName,
        alias: `${object.constructor.name}_${propertyName}`,
        primaryKey: false,
        ...columnOptions
      },
      ...columnOptions
    };
    const type = options.type;

    SimpleORM.propertyMetaCollection.push(new PropertyMeta({
      fn: object.constructor,
      className: object.constructor.name,
      propertyName,
      object,
      type,
      options
    }));
  };
}

export function CreateDateColumn(options) {
  return function (object, propertyName) {
  };
}

export function ObjectIdColumn(columnOptions) {
  return function (object, propertyName) {
  };
}

export function PrimaryColumn(typeOrOptions, options?) {
  return function (object, propertyName) {
  };
}

export function PrimaryGeneratedColumn(columnOptions) {

  return function (object, propertyName) {
    const options: IPropertyMetaOptions = {
      type: 'string',
      sql: {
        name: propertyName,
        alias: `${object.constructor.name}_${propertyName}`,
        primaryKey: true,
        unique: true,
        ...columnOptions
      },
      ...columnOptions
    };

    SimpleORM.propertyMetaCollection.push(new PropertyMeta({
      fn: object.constructor,
      className: object.constructor.name,
      propertyName,
      primaryColumn: true,
      autoGenerated: true,
      object,
      options,
      columnOptions,
      meta: { }
    }));
  };
}

export function UpdateDateColumn(options) {
  return function (object, propertyName) {
  };
}

export function VersionColumn(options) {
  return function (object, propertyName) {
  };
}

// entities
export function ChildEntity(tableName, options?) {
  return function (object) {
  };
}

export function Entity(tableName: string, options?) {
  return function (object) {
    SimpleORM.classMetaCollection.push({
      fn: object,
      className: object.name,
      object,
      tableName,
      options
    });
  };
}

export function TableInheritance(type) {
  return function (object) {
  };
}

// listeners

export function AfterInsert() {
  return function (object, propertyName) {
  };
}

export function AfterLoad() {
  return function (object, propertyName) {
  };
}

export function AfterRemove() {
  return function (object, propertyName) {
  };
}

export function AfterUpdate() {
  return function (object, propertyName) {
  };
}

export function BeforeInsert() {
  return function (object, propertyName) {
  };
}

export function BeforeRemove() {
  return function (object, propertyName) {
  };
}

export function BeforeUpdate() {
  return function (object, propertyName) {
  };
}

function EventSubscriber() {
  return function (object, propertyName) {
  };
}


// relations
function JoinColumn(options) {
  return function (object, propertyName) {
  };
}

function JoinTable(options) {
  return function (object, propertyName) {
  };
}

function ManyToMany(typeFunction, inverseSideOrOptions, options?) {
  return function (object, propertyName) {
  };
}

export function ManyToOne<T,R>(typeFunction: (type?: any) => Constructor<T>, inverseSide: (object: T) => R, columnOptions?) {

  return function (object, propertyName) {
    const options = {
      type: undefined,
      sql: {
        // name: propertyName,
        // alias: `${object.constructor.name}_${propertyName}`,
        ...columnOptions
      },
      typeFunction,
      inverseSide,
      ...columnOptions
    };
    const type = options.type;

    SimpleORM.propertyMetaCollection.push(new PropertyRelationMeta({
      fn: object.constructor,
      className: object.constructor.name,
      propertyName,
      object,
      type,
      options,
      columnOptions,
      meta: {
        relation: {
          type: EntityRelationType.ManyToOne,
          base: {
            getFn: typeFunction,
            property: undefined
          },
          related: {
            getFn: () => object.constructor,
            property: propertyName
          }
        }
      }
    }));
  };
}

export function OneToMany<T, R>(typeFunction: (type?: any) => Constructor<T>, inverseSide: (object: T) => R, columnOptions?) {

  return function (object, propertyName) {
    const options = {
      type: undefined,
      sql: {
        // name: propertyName,
        // alias: `${object.constructor.name}_${propertyName}`,
        ...columnOptions
      },
      typeFunction,
      inverseSide,
      ...columnOptions
    };
    const type = options.type;

    SimpleORM.propertyMetaCollection.push(new PropertyRelationMeta({
      fn: object.constructor,
      className: object.constructor.name,
      propertyName,
      object,
      type,
      options,
      columnOptions,
      meta: {
        relation: {
          type: EntityRelationType.OneToMany,
          base: {
            getFn: () => object.constructor,
            property: propertyName
          },
          related: {
            getFn: typeFunction,
            property: undefined
          }
        }
      }
    }));
  };
}

function OneToOne(typeFunction, inverseSideOrOptions, options?) {
  return function (object, propertyName) {
  };
}

function RelationCount(relation) {
  return function (object, propertyName) {
  };
}

function RelationId(relation) {
  return function (object, propertyName) {
  };
}


// tree
function Tree(name, options?) {
  return function (object) {
  };
}

function TreeChildren(options) {
  return function (object, propertyName) {
  };
}

function TreeChildrenCount(options) {
  return function (object, propertyName) {
  };
}

function TreeLevelColumn() {
  return function (object, propertyName) {
  };
}

function TreeParent(options) {
  return function (object, propertyName) {
  };
}

function Generated(options) {
  return function (object, propertyName) {
  };
}

function Index(options) {
  return function (object, propertyName) {
  };
}
